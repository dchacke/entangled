{
  "name": "postcss",
  "version": "0.3.5",
  "description": "Framework for CSS postprocessors",
  "keywords": [
    "css",
    "parser",
    "postproccessor"
  ],
  "author": {
    "name": "Andrey Sitnik",
    "email": "andrey@sitnik.ru"
  },
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "https://github.com/ai/postcss.git"
  },
  "dependencies": {
    "source-map": "~0.1.33",
    "base64-js": "~0.0.6"
  },
  "devDependencies": {
    "coffee-script": "1.7.1",
    "fs-extra": "0.9.1",
    "gonzales": "1.0.7",
    "rework": "0.20.3",
    "should": "4.0.0",
    "mocha": "1.20.0",
    "cssom": "0.3.0"
  },
  "main": "lib/postcss",
  "scripts": {
    "test": "mocha"
  },
  "readme": "# PostCSS\n\nPostCSS is a framework for CSS postprocessors,\nto modify CSS with JavaScript.\n\nIt takes care of most common CSS tool tasks:\n\n1. parses CSS;\n2. gives you usable JS API to edit CSS node tree;\n3. dumps modified node tree into CSS string;\n4. generates (or modifies existent) source map for your changes;\n\nYou can use this framework to write you own:\n\n* CSS minifier or beautifizer.\n* CSS polyfills.\n* Grunt plugin to generate sprites, include `data-uri` images\n  or any other works.\n* Text editor plugin to automate CSS routine.\n* Command-line CSS tool.\n\nSponsored by [Evil Martians](http://evilmartians.com/).\n\n## Built with PostCSS\n\n* [Autoprefixer] adds vendor prefixes by Can I Use data.\n* [grunt-pixrem], `rem` unit polyfill.\n* [CSS MQPacker] joins same media queries.\n* [RTLCSS] mirrors styles for right-to-left locales.\n* [CSSWring] and [grunt-csswring] CSS minifier with full source map support.\n* [Grunt-webpcss] to duplicate images in CSS to WebP for supported browsers.\n* [Pleeease] is a pack of various postprocessors.\n\n[grunt-csswring]: https://github.com/princed/grunt-csswring\n[Grunt-webpcss]:  https://github.com/lexich/grunt-webpcss\n[Autoprefixer]:   https://github.com/ai/autoprefixer\n[grunt-pixrem]:   https://github.com/robwierzbowski/grunt-pixrem\n[CSS MQPacker]:   https://github.com/hail2u/node-css-mqpacker\n[Pleeease]:       http://pleeease.io/\n[CSSWring]:       https://github.com/hail2u/node-csswring\n[RTLCSS]:         https://github.com/MohammadYounes/rtlcss\n\n## Quick Example\n\nLet’s fix forgotten `content` property in `::before` and `::after`:\n\n```js\nvar postcss = require('postcss');\n\nvar contenter = postcss(function (css) {\n    css.eachRule(function (rule) {\n        if ( rule.selector.match(/::(before|after)/) ) {\n            // In every ::before/::after rule\n\n            // Did we forget content property?\n            var good = rule.some(function (i) { return i.prop == 'content'; });\n\n            if ( !good ) {\n                // Add content: \"\" if we forget it\n                rule.prepend({ prop: 'content', value: '\"\"' });\n            }\n\n        }\n    });\n});\n```\n\nAnd then CSS with forgotten `content`:\n\n```css\na::before {\n    width: 10px;\n    height: 10px\n}\n```\n\nwill be fixed by our new `contenter`:\n\n```js\nvar fixed = contenter.process(css).css;\n```\n\nto:\n\n```css\na::before {\n    content: \"\";\n    width: 10px;\n    height: 10px\n}\n```\n\n## Features\n\n### Source Map\n\nPostCSS generates source map for its changes:\n\n```js\nresult = processor.process(css, { map: true, from: 'from.css', to: 'to.css' });\nresult.css // String with processed CSS\nresult.map // Source map\n```\n\nAnd modifies source map from previous step (like Sass preprocessor):\n\n```js\nvar sassMap = fs.readFileSync('from.sass.css.map');\nprocessor.process(css, { map: sassMap, from: 'from.sass.css', to: 'to.css' });\n```\n\n### Preserves code formatting and indentations\n\nPostCSS will not change any byte of a rule if you don’t modify its node:\n\n```js\npostcss(function (css) { }).process(css).css == css;\n```\n\nAnd when you modify CSS nodes, PostCSS will try to copy coding style:\n\n```js\ncontenter.process(\"a::before{color:black}\")\n// a::before{content:'';color:black}\n\ncontenter.process(\"a::before {\\n  color: black;\\n  }\")\n// a::before {\n//   content: '';\n//   color: black;\n//   }\n```\n\n## Why PostCSS Better Than …\n\n### Preprocessors\n\nPreprocessors (like Sass or Stylus) give us special language with variables,\nmixins, statements and compile it to CSS. Compass, nib and other mixins\nlibraries use these languages to work with prefixes, sprites and inline images.\n\nBut Sass and Stylus languages were created to be syntax-sugar for CSS.\nWriting really complicated programs using preporcessor languages\nis very difficult. [Autoprefixer] is absolutely impossible to implement\non top of Sass.\n\nPostCSS gives you comfort and power of JS or CoffeeScript to working with CSS.\nYou can do really magic things with wide range of [npm] libraries.\n\nBut postprocessors are not enemies for preprocessors. Sass and Stylus are still\nthe best way to improve readability and add some syntax sugar to CSS.\nYou can easily combine preprocessors and postprocessors\n(and PostCSS will also update source map from Sass or Stylus).\n\n[Autoprefixer]: https://github.com/ai/autoprefixer\n[npm]:          https://npmjs.org/\n\n### RegExp\n\nSome Grunt plugins modify CSS with regular expressions but using a CSS parser\nand a node tree is a much safer way to edit CSS. Also, regexps will break\nsource maps generated by preprocessors.\n\n### CSS Parsers\n\nThere are a lot of good CSS parsers, like [Gonzales]. But they help you only\nwith first step.\n\nUnlike them PostCSS gives you full source map support and useful high level API\n(for example, safe iterators).\n\n[Gonzales]: https://github.com/css/gonzales\n\n### Rework\n\n[Rework] and PostCSS are very similar, but they has different targets.\n\nRework was created to build new CSS sublanguage to replace Stylus (like [Myth]).\nPostCSS was created for CSS tools, which works in chain with legacy CSS code\n(like Autoprefixer).\n\nBecause of this background difference, PostCSS:\n\n* better works with source map, because it should update map from previous step\n  (like Sass compiling)\n* saves all your spaces and code style, because it can be worked in text editor\n  plugins\n* has safer parser, because it can be used for legacy code\n* has high level API to clean your processor from common tasks\n\n[Myth]:   http://www.myth.io/\n[Rework]: https://github.com/visionmedia/rework\n\n## Usage\n\nYou can parse CSS by `postcss.parse()` method, which returns CSS AST:\n\n```js\nvar postcss = require('postcss');\n\nvar css = postcss.parse('a { color: black }');\n```\n\nThen you can change this AST. Use `css.list` to get childs.\nProperties `rule.selector`, `decl.prop`, `decl.value`, `atrule.name`\nand `atrule.params` contain data.\n\nDon’t use underscore properties (like `_selector`, `_params` and `_value`),\nbecause they are only for comments save magic\n(See [Raw Properties](#Raw Properties) below). Use getters and setters instead\n(like `selector`, `selectors`, `params` and `value`).\n\n```js\ncss.list[0].value = 'white';\n```\n\nAfter changes you can get new CSS and modification’s source map:\n\n```js\nvar result = css.toResult(options);\n\nresult.css //=> 'a { color: white }'\nresult.map //=> '{\"version\":3, … }'\n```\n\nMethods `postcss.parse()` and `CSS#toResult()` are low level API, for most cases\nit will be better to create processors with simplier API and chaining.\n\n### Processor\n\nThe function `postcss(fn)` creates a processor from your function:\n\n```js\nvar postcss = require('postcss');\n\nvar processor = postcss(function (css) {\n    // Code to modify CSS\n});\n```\n\nIf you want to combine multiple processors (and parse CSS only once),\nyou can add several functions using the `use(fn)` method:\n\n```js\nvar all = postcss().\n          use(prefixer).\n          use(minifing);\n```\n\nProcessor function can change the current CSS node tree:\n\n```js\npostcss(function (css) {\n    css.append( /* new rule */ )\n});\n```\n\nor create a completely new CSS root node and return it instead:\n\n```js\npostcss(function (css) {\n    var newCSS = postcss.root()\n    // Add rules and declarations\n    return newCSS;\n});\n```\n\nThis generated processor transforms some CSS using `process(css, opts)` method:\n\n```js\nvar doubler = postcss(function (css) {\n    // Clone each declaration\n    css.eachDecl(function (decl) {\n        decl.parent.prepend( decl.clone() );\n    });\n});\n\nvar css    = \"a { color: black; }\";\nvar result = doubler.process(css);\n\nresult.css //=> \"a { color: black; color: black; }\"\n```\n\nYou can set the original CSS filename via `from` option and make syntax error\nmessages much more helpful:\n\n```js\nvar wrong = \"a {\";\nprocessor.process(wrong, { from: 'main.css' });\n//=> Can't parse CSS: Unclosed block at line 1:1 in main.css\n```\n\nYou can also use result from previous postprocessor or already parsed `Root`\nas argument in next one:\n\n```js\nresult = processor1.process(css)\nprocessor2.process(result)\n```\n\n### Multiple Inputs\n\nThe function `postcss()` generates processor only for one input.\nIf you need to process several inputs (like in files concatenation) you can use\n`postcss.parse()`.\n\nLet’s join two CSS with source map support in 5 lines of code:\n\n```js\nvar file1 = postcss.parse(css1, { from: 'a.css' });\nvar file2 = postcss.parse(css2, { from: 'b.css' });\n\nfile1.rules = file1.rules.concat( file2.rules );\n\nvar result = file1.toResult({ to: 'app.css', map: true });\n```\n\n### Source Map\n\nPostCSS will generate a source map, if you set `map` option to `true`\nin the `process(css, opts)` method.\n\nYou must set input and output CSS files paths (using `from` and `to`\noptions respectively) to generate correct source map.\n\n```js\nvar result = processor.process(css, {\n    map:  true,\n    from: 'main.css',\n    to:   'main.out.css'\n});\n\nresult.map //=> '{\"version\":3,\"file\":\"main.out.css\",\"sources\":[\"main.css\"],\"names\":[],\"mappings\":\"AAAA,KAAI\"}'\n\nfs.writeFileSync('main.out.css.map', result.map);\n```\n\nPostCSS can also modify previous source map (for example, from Sass\ncompilation). So if you compile Sass to CSS and then minify this CSS\nby postprocessor, final source map will contain mapping from Sass code\nto minified CSS.\n\nJust set `map` option with an original source map (a string or a JS object):\n\n```js\nvar result = minifier.process(css, {\n    map:   fs.readFileSync('main.sass.css.map'),\n    from: 'main.sass.css',\n    to:   'main.min.css'\n});\n\nresult.map //=> Source map from main.sass to main.min.css\n```\n\nPostCSS try to autodetect previous map file. For example, if you process `a.css`\nand `a.css.map` is placed in same dir, PostCSS will read previous map and\ngenerate new one. You can disable autodetection by `map: false`.\n\nPostCSS, by default, will add annotation comment with path to new source map\nfile:\n\n```css\na { }\n/*# sourceMappingURL=main.out.css.map */\n```\n\nIf you want to remove annotation, set `mapAnnotation` option to `false`.\n\nInline maps are also supported. If input CSS will contain annotation\nfrom previous step with map in `data:uri`, PostCSS will update source map\nwith yours changes and inine new map back to output CSS.\n\nOption `inlineMap` will force PostCSS to inline new map to CSS:\n\n```js\nvar result = minifier.process(css, {\n    from:     'main.css',\n    to:       'main.min.css',\n    inlineMap: true\n});\n\nresult.map //=> undefined, because map is in CSS\nresult.css //=> \"a{}\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFpbi5taW4uY3NzIiwic291cmNlcyI6WyJtYWluLmNzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxJQUFLIn0= */\"\n```\n\n### Helpers\n\n#### Vendor\n\nPostCSS contains heigh optimized code to split vendor prefix:\n\n```js\nvar vendor = require('postcss/lib/vendor');\n\nvendor.prefix('-moz-tab-size')     //=> '-moz-'\nvendor.unprefixed('-moz-tab-size') //=> 'tab-size'\n```\n\n#### List\n\nTo safely split comma- or space-separated values (like in `background-image`\nor `transform` ) with brackets and quotes support you can use `list` helper:\n\n```js\nvar list = require('postcss/lib/list');\n\nlist.space(image.value)     //=> ['linear-gradient(white, black)', 'blue']\nlist.comma(transform.value) //=> ['color 200ms', 'background 200ms']\n```\n\n### Nodes\n\nProcessor function receives `Root` node with CSS node tree inside.\n\n```js\nvar processor = postcss(function (cssRoot) {\n});\n```\n\nThere are 4 types of child nodes: `Comment`, `AtRule`, `Rule` and `Declaration`.\nAll nodes have `toString()` and `clone()` methods.\n\nYou can parse CSS and get a `Root` node by `postcss.parse(css, opts)` method:\n\n```js\nvar cssRoot = postcss.parse('a { }');\n```\n\nAll node‘s methods return current node, so you can build nice method chains:\n\n```js\nroot.append( rule1 ).append( rule2 ).toString();\n```\n\n### Node Source\n\nEvery node stores its origin file (if you set `from` option to `process`\nor `parse` method) and position:\n\n```js\nvar root = postcss.parse(css, { from: 'main.css' });\nvar rule = root.rules[0];\n\nrule.source.file  //=> 'main.css'\nrule.source.start //=> { line: 5,  position: 1 }\nrule.source.end   //=> { line: 10, position: 5 }\n```\n\n### Whitespaces\n\nAll nodes (exclude `Root`) have `before` property with indentation\nand all earlier spaces.\n\nNodes with children (`Root`, `AtRule` and `Rule`) contain also `after` property\nwith spaces after last child and before `}` or end of file.\n\nEvery `Declaration` has `between` property with colon, spaces and comments\nbetween property name and value. `Rule` stores spaces and comments between\nselector and `{` in `between` property. `AtRule` uses `between` also to store\nspaces and comments before `{` or `;` for bodiless at-rule.\n\n```js\nvar root = postcss.parse(\"a {\\n  color: black;\\n}\\n\");\n\nroot.rules[0].between          //=> \" \" between selector and {\nroot.rules[0].decls[0].before  //=> \"\\n  \" before color: black\nroot.rules[0].decls[0].between //=> \": \" between property name and value\nroot.rules[0].after            //=> \"\\n\" before }\nroot.after                     //=> \"\\n\" from end of file\n```\n\nThe simplest way to minify CSS is to set `before`, `between` and `after`\nproperties to an empty string:\n\n```js\nvar minifier = postcss(function (css) {\n    css.eachDecl(function (decl) {\n        decl.before  = '';\n        decl.between = ':';\n    });\n    css.eachRule(function (rule) {\n        rule.before  = '';\n        rule.between = '';\n        rule.after   = '';\n    });\n    css.eachAtRule(function (atRule) {\n        atRule.before  = '';\n        atRule.between = '';\n        atRule.after   = '';\n    });\n    css.eachComment(function (comment) {\n        comment.removeSelf();\n    });\n});\n\nvar css = \"a {\\n  color:black\\n}\\n\";\nminifier.process(css).css //=> \"a{color:black}\"\n```\n\n### Raw Properties\n\nSome CSS values (selectors, comment text, at-rule params and declaration values)\ncan contain comments. PostCSS will clean them from trailing spaces for you:\n\n```js\nvar root = postcss.parse(\"a /**/ b {}\");\nvar rule  = root.rules[0];\n\nrule.selector      //=> 'a  b' trimmed and cleaned from comments\nrule._selector.raw //=> 'a /**/ b' original raw value\n```\n\nBut PostCSS saves raw content to be able to stringify it to CSS, if you don’t\nchange origin value. As you can remember, PostCSS tries to save origin CSS\nbyte-to-byte, when it’s possible:\n\n```js\nrule.toString() //=> 'a /**/ b {}' with comment\n\nrule.selector = '.link b';\nrule.toString() //=> '.link b {}' you change value and origin comment was gone\n```\n\n### Containers\n\n`Root`, `AtRule` and `Rule` nodes can contain children in `rules` or `decls`\nproperty.\n\nThere are common method to work with children:\n\n* `append(newChild)` to add child at the end of children list.\n* `prepend(newChild)` to add child at the beginning of children list.\n* `insertBefore(existsChild, newChild)` to insert new child before some\n   existent child.\n* `insertAfter(existsChild, newChild)` to insert new child after some\n   existent child.\n* `remove(existsChild)` to remove child.\n* `index(existsChild)` to return child index.\n* `some(fn)` to return true if `fn` returns true on any child.\n* `every(fn)` to return true if `fn` returns true on all children.\n\nMethods `insertBefore`, `insertAfter` and `remove` can receive child node\nor child index as an `existsChild` argument. Have in mind that child index works\nmuch faster.\n\nThere are two shorcuts to get first and last child:\n\n```js\nrule.first //=> First declaration in rule\nrule.last  //=> Last declaration in rule\n```\n\n### Children\n\n`Comment`, `AtRule`, `Rule` and `Declaration` nodes should be wrapped\nin other nodes.\n\nAll children contain `parent` property with parent node:\n\n```js\nrule.decls[0].parent == rule;\n```\n\nAll children has `removeSelf()` method:\n\n```js\nrule.decls[0].removeSelf();\n```\n\nBut `remove(index)` in parent with child index is much faster:\n\n```js\nrule.each(function (decl, i) {\n    rule.remove(i);\n});\n```\n\n### Iterators\n\nAll parent nodes have `each` method to iterate over children nodes:\n\n```js\nroot = postcss.parse('a { color: black; display: none }');\n\nroot.each(function (rule, i) {\n    if ( rule.type == 'rule' ) {\n        console.log(rule.selector, i); // Will log \"a 0\"\n    }\n});\n\nroot.rules[0].each(function (decl, i) {\n    if ( rule.type != 'comment' ) {\n        console.log(decl.prop, i); // Will log \"color 0\" and \"display 1\"\n    }\n});\n```\n\nUnlike `for {}`-cycle construct or `Array#forEach()` this iterator is safe.\nYou can mutate children while iteration and it will fix current index:\n\n```js\nrule.rules.forEach(function (decl, i) {\n    rule.prepend( decl.clone() );\n    // Will be infinity cycle, because on prepend current declaration become\n    // second and next index will go to current declaration again\n});\n\nrule.each(function (decl, i) {\n    rule.prepend( decl.clone() );\n    // Will work correct (once clone each declaration), because after prepend\n    // iterator index will be recalculated\n});\n```\n\nBecause CSS have nested structure, PostCSS also contains recursive iterator\n`eachInside`:\n\n```js\nroot.eachInside(function (node, i) {\n    console.log(node.type + ' inside ' + node.parent.type);\n});\n```\n\nThere are also shortcuts to recursive iterate all nodes of specific type:\n\n```js\nroot.eachDecl(function (decl, i) {\n    // Each declaration inside root\n});\n\nroot.eachRule(function (rule, i) {\n    // Each rule inside root and any nested at-rules\n});\n\nroot.eachAtRule(function (atRule, i) {\n    // Each at-rule inside root and any nested at-rules\n});\n\nroot.eachComment(function (comment, i) {\n    // Each comment inside root\n})\n```\n\nYou can break iteration by `return false`.\n\n### Root Node\n\n`Root` node contains entire CSS tree. Its children can be only `Comment`,\n`AtRule` or `Rule` nodes in `rules` property.\n\nYou can create a new root using shortcut:\n\n```js\nvar root = postcss.root();\n```\n\nMethod `toString()` stringifies entire node tree to CSS string:\n\n```js\nroot = postcss.parse(css);\nroot.toString() == css;\n```\n\n### Comment Node\n\n```css\n/* Block comment */\n```\n\nPostCSS creates `Comment` nodes only for comments between rules or declarations.\nComments inside selectors, at-rules params, declaration values will be stored\nin Raw property.\n\n`Comment` has only one property: `text` with trimmed text inside comment.\n\n```js\ncomment.text //=> \"Block comment\"\n```\n\nYou can create a new comment using shortcut:\n\n```js\nvar comment = postcss.comment({ text: 'New comment' });\n```\n\n### AtRule Node\n\n```css\n@charset 'utf-8';\n\n@font-face {\n    font-family: 'Cool'\n}\n\n@media print {\n    img { display: none }\n}\n```\n\n`AtRule` has two own properties: `name` and `params`.\n\nAs you see, some at-rules don’t contain any children (like `@charset`\nor `@import`), some of at-rules can contain only declarations\n(like `@font-face` or `@page`), but most of them can contain rules\nand nested at-rules (like `@media`, `@keyframes` and others).\n\nParser selects `AtRule` content type by its name. If you create `AtRule`\nnode manually, it will detect own content type with new child type on first\n`append` or other add method call:\n\n```js\nvar atRule = postcss.atRule({ name: '-x-animations' });\natRule.rules        //=> undefined\natRule.decls        //=> undefined\n\natRule.append( postcss.rule({ selector: 'from' }) );\natRule.rules.length //=> 1\natRule.decls        //=> undefined\n```\n\nYou can create a new at-rule using shortcut:\n\n```js\nvar atRule = postcss.atRule({ name: 'charset', params: 'utf-8' });\n```\n\n### Rule Node\n\n```css\na {\n    color: black;\n}\n```\n\n`Rule` node has `selector` property and contains `Declaration` and `Comment`\nchildren in `decls` property.\n\nThere is `selectors` shortcut, which return array:\n\n```js\nrule.selector  //=> \"a, b\"\nrule.selectors //=> ['a', 'b']\n```\n\nYou can miss `Declaration` constructor in `append` and other insert methods:\n\n```js\nrule.append({ prop: 'color', value: 'black' });\n```\n\nProperty `semicolon` indicates if last declaration in rule has semicolon or not:\n\n```js\nvar root = postcss.parse('a { color: black }');\nroot.rules[0].semicolon //=> false\n\nvar root = postcss.parse('a { color: black; }');\nroot.rules[0].semicolon //=> true\n```\n\nYou can create a new rule using shortcut:\n\n```js\nvar rule = postcss.rule({ selector: 'a' });\n```\n\n### Declaration Node\n\n```css\ncolor: black\n```\n\n`Declaration` node has `prop`, `value` and `important` properties.\n\nYou can create a new declaration using this shortcut:\n\n```js\nvar decl = postcss.decl({ prop: 'color', value: 'black' });\n```\n\nOr use short form in rule’s `append()` and other add methods:\n\n```js\nrule.append({ prop: 'color', value: 'black' });\n```\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/ai/postcss/issues"
  },
  "homepage": "https://github.com/ai/postcss",
  "_id": "postcss@0.3.5",
  "_shasum": "5073a3d062ef3ce592ac4a5fe6b8c2862ab83ceb",
  "_from": "postcss@~0.3.5",
  "_resolved": "https://registry.npmjs.org/postcss/-/postcss-0.3.5.tgz"
}
